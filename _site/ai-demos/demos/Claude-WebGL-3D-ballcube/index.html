<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BallCube Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: monospace;
            color: #fff;
        }
        
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }
        
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 12px;
            opacity: 0.7;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            .info {
                font-size: 10px;
            }
            
            canvas {
                touch-action: none;
            }
        }
        
        @media (max-width: 480px) {
            .info {
                font-size: 8px;
                opacity: 0.5;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info">BallCube WebGL Demo | Touch/Click to interact</div>

    <!-- Vertex Shader for Spheres -->
    <script id="sphere-vertex-shader" type="x-shader/x-vertex">
        precision mediump float;
        
        attribute vec3 a_position;
        attribute vec3 a_instancePosition;
        attribute float a_instanceScale;
        
        uniform mat4 u_mvpMatrix;
        uniform mediump float u_time;
        
        varying vec3 v_position;
        varying float v_depth;
        
        void main() {
            // Pulsing effect like the raymarching example
            float pulseRadius = 0.2 + 0.05 * sin(u_time * 2.0 + length(a_instancePosition));
            float pulse = pulseRadius / 0.2; // Scale relative to base radius
            vec3 scaledPos = a_position * a_instanceScale * pulse;
            vec3 worldPos = scaledPos + a_instancePosition;
            
            gl_Position = u_mvpMatrix * vec4(worldPos, 1.0);
            v_position = worldPos;
            v_depth = gl_Position.z / gl_Position.w;
        }
    </script>

    <!-- Fragment Shader for Spheres -->
    <script id="sphere-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        uniform mediump float u_time;
        uniform vec3 u_lightDirection;
        
        varying vec3 v_position;
        varying float v_depth;
        
        void main() {
            vec3 normal = normalize(v_position);
            float lighting = max(0.3, dot(normal, u_lightDirection));
            
            // Synced color change like the raymarching example
            vec3 baseColor = vec3(
                0.5 + 0.5 * sin(u_time * 0.5), // Sync with rotateX
                0.5 + 0.5 * sin(u_time * 0.3 + 1.57), // Sync with rotateY, phase offset
                0.5 + 0.5 * sin(u_time * 0.2 + 3.14)  // Sync with rotateZ, phase offset
            );
            
            vec3 color = baseColor * (0.2 + 0.8 * lighting);
            
            // Add specular highlights
            vec3 viewDir = normalize(-v_position);
            vec3 halfDir = normalize(u_lightDirection + viewDir);
            float spec = pow(max(dot(normal, halfDir), 0.0), 32.0);
            color += vec3(1.0) * spec * 0.5;
            
            // Add glow based on pulse
            float glow = 0.5 + 0.5 * sin(u_time * 2.0 + length(v_position));
            color += baseColor * glow * 0.3;
            
            // Depth-based fog effect
            float fogFactor = clamp((v_depth + 0.5) * 0.8, 0.0, 1.0);
            
            vec3 finalColor = color * fogFactor;
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <!-- Vertex Shader for Stars -->
    <script id="star-vertex-shader" type="x-shader/x-vertex">
        precision mediump float;
        
        attribute vec2 a_position;
        attribute vec2 a_starPosition;
        attribute float a_starSize;
        attribute float a_starBrightness;
        
        uniform mat4 u_projectionMatrix;
        uniform mediump float u_time;
        uniform vec2 u_resolution;
        
        varying float v_brightness;
        varying vec2 v_uv;
        
        void main() {
            v_uv = a_position;
            v_brightness = a_starBrightness;
            
            vec2 screenPos = a_starPosition;
            vec2 vertexOffset = a_position * a_starSize;
            
            gl_Position = vec4((screenPos + vertexOffset) / u_resolution * 2.0 - 1.0, 0.0, 1.0);
            gl_Position.y *= -1.0;
        }
    </script>

    <!-- Fragment Shader for Stars -->
    <script id="star-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        uniform mediump float u_time;
        
        varying float v_brightness;
        varying vec2 v_uv;
        
        void main() {
            float dist = length(v_uv);
            float alpha = smoothstep(1.0, 0.3, dist) * v_brightness;
            
            // Star twinkling effect
            float twinkle = sin(u_time * 5.0 + v_uv.x * 10.0 + v_uv.y * 10.0) * 0.3 + 0.7;
            alpha *= twinkle;
            
            // Color variation for different star types
            vec3 color = mix(
                vec3(1.0, 0.9, 0.7),  // Warm white
                vec3(0.7, 0.9, 1.0),  // Cool blue
                sin(u_time * 0.3 + v_uv.x * 5.0) * 0.5 + 0.5
            );
            
            gl_FragColor = vec4(color * alpha, alpha);
        }
    </script>

    <script>
        // Matrix utilities (embedded gl-matrix subset)
        const mat4 = {
            create() {
                return new Float32Array(16);
            },
            
            identity(out) {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
                return out;
            },
            
            perspective(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                const nf = 1 / (near - far);
                
                out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
                out[12] = 0; out[13] = 0; out[14] = 2 * far * near * nf; out[15] = 0;
                return out;
            },
            
            translate(out, a, v) {
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
                out[12] = a[0] * v[0] + a[4] * v[1] + a[8] * v[2] + a[12];
                out[13] = a[1] * v[0] + a[5] * v[1] + a[9] * v[2] + a[13];
                out[14] = a[2] * v[0] + a[6] * v[1] + a[10] * v[2] + a[14];
                out[15] = a[3] * v[0] + a[7] * v[1] + a[11] * v[2] + a[15];
                return out;
            },
            
            rotateX(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                out[4] = a10 * c + a20 * s;
                out[5] = a11 * c + a21 * s;
                out[6] = a12 * c + a22 * s;
                out[7] = a13 * c + a23 * s;
                out[8] = a20 * c - a10 * s;
                out[9] = a21 * c - a11 * s;
                out[10] = a22 * c - a12 * s;
                out[11] = a23 * c - a13 * s;
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                return out;
            },
            
            rotateY(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                
                out[0] = a00 * c - a20 * s;
                out[1] = a01 * c - a21 * s;
                out[2] = a02 * c - a22 * s;
                out[3] = a03 * c - a23 * s;
                out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                out[8] = a00 * s + a20 * c;
                out[9] = a01 * s + a21 * c;
                out[10] = a02 * s + a22 * c;
                out[11] = a03 * s + a23 * c;
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                return out;
            },
            
            rotateZ(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                
                out[0] = a00 * c + a10 * s;
                out[1] = a01 * c + a11 * s;
                out[2] = a02 * c + a12 * s;
                out[3] = a03 * c + a13 * s;
                out[4] = a10 * c - a00 * s;
                out[5] = a11 * c - a01 * s;
                out[6] = a12 * c - a02 * s;
                out[7] = a13 * c - a03 * s;
                out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                return out;
            },
            
            multiply(out, a, b) {
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                
                const b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
                const b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
                const b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
                const b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];
                
                out[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;
                out[1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;
                out[2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;
                out[3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;
                out[4] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;
                out[5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;
                out[6] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;
                out[7] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;
                out[8] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;
                out[9] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;
                out[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;
                out[11] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;
                out[12] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;
                out[13] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;
                out[14] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;
                out[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;
                return out;
            }
        };

        // WebGL Demo Class
        class BallCubeDemo {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.gl = null;
                this.programs = {};
                this.buffers = {};
                this.time = 0;
                this.mouseX = 0;
                this.mouseY = 0;
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                this.performanceLevel = this.isMobile ? 0.5 : 1.0;
                
                this.init();
            }
            
            init() {
                this.setupWebGL();
                if (!this.setupShaders()) {
                    console.error('Shader setup failed');
                    return;
                }
                this.setupBuffers();
                this.setupEventListeners();
                this.render();
            }
            
            setupWebGL() {
                this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
                if (!this.gl) {
                    alert('WebGL not supported');
                    return;
                }
                
                this.resizeCanvas();
                
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
            }
            
            resizeCanvas() {
                const displayWidth = window.innerWidth;
                const displayHeight = window.innerHeight;
                
                if (this.canvas.width !== displayWidth || this.canvas.height !== displayHeight) {
                    this.canvas.width = displayWidth;
                    this.canvas.height = displayHeight;
                    this.gl.viewport(0, 0, displayWidth, displayHeight);
                }
            }
            
            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            createProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);
                
                if (!vertexShader || !fragmentShader) {
                    console.error('Failed to create shaders');
                    return null;
                }
                
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);
                
                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program link error:', this.gl.getProgramInfoLog(program));
                    this.gl.deleteProgram(program);
                    return null;
                }
                
                // Clean up shaders
                this.gl.deleteShader(vertexShader);
                this.gl.deleteShader(fragmentShader);
                
                return program;
            }
            
            setupShaders() {
                const sphereVertexSource = document.getElementById('sphere-vertex-shader').textContent;
                const sphereFragmentSource = document.getElementById('sphere-fragment-shader').textContent;
                const starVertexSource = document.getElementById('star-vertex-shader').textContent;
                const starFragmentSource = document.getElementById('star-fragment-shader').textContent;
                
                this.programs.sphere = this.createProgram(sphereVertexSource, sphereFragmentSource);
                this.programs.star = this.createProgram(starVertexSource, starFragmentSource);
                
                if (!this.programs.sphere || !this.programs.star) {
                    console.error('Failed to create shader programs');
                    return false;
                }
                
                return true;
            }
            
            setupBuffers() {
                this.setupSphereBuffers();
                this.setupStarBuffers();
            }
            
            setupSphereBuffers() {
                const sphereData = this.generateSphere(16, 16);
                const cubePositions = this.generateCubePositions(8);
                
                this.buffers.spherePosition = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.spherePosition);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(sphereData.vertices), this.gl.STATIC_DRAW);
                
                this.buffers.sphereIndex = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.sphereIndex);
                this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphereData.indices), this.gl.STATIC_DRAW);
                
                this.buffers.instancePosition = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.instancePosition);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(cubePositions), this.gl.STATIC_DRAW);
                
                const scales = new Array(cubePositions.length / 3).fill(0.2); // Match base radius from example
                this.buffers.instanceScale = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.instanceScale);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(scales), this.gl.STATIC_DRAW);
                
                this.sphereIndexCount = sphereData.indices.length;
                this.instanceCount = cubePositions.length / 3;
            }
            
            setupStarBuffers() {
                const starQuad = [-1, -1, 1, -1, 1, 1, -1, 1];
                
                this.movingStars = [];
                this.explodingStars = [];
                this.blackHoleStars = [];
                
                // Adjust star counts based on performance level
                const movingStarCount = Math.floor(150 * this.performanceLevel);
                const explodingStarCount = Math.floor(20 * this.performanceLevel);
                const blackHoleStarCount = Math.floor(100 * this.performanceLevel);
                
                // Moving stars (bottom-left to top-right)
                for (let i = 0; i < movingStarCount; i++) {
                    this.movingStars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 2 + 0.5,
                        brightness: Math.random() * 0.6 + 0.4,
                        speed: Math.random() * 50 + 25
                    });
                }
                
                // Exploding stars
                for (let i = 0; i < explodingStarCount; i++) {
                    this.explodingStars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        particles: [],
                        nextExplosion: Math.random() * 5,
                        exploding: false
                    });
                }
                
                // Black hole stars (spiral pattern)
                const centerX = this.canvas.width * 0.7;
                const centerY = this.canvas.height * 0.3;
                for (let i = 0; i < blackHoleStarCount; i++) {
                    const angle = Math.random() * Math.PI * 4;
                    const radius = Math.random() * 150 + 50;
                    this.blackHoleStars.push({
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius,
                        angle: angle,
                        radius: radius,
                        size: Math.random() * 1.5 + 0.5,
                        brightness: Math.random() * 0.8 + 0.2
                    });
                }
                
                this.buffers.starQuad = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.starQuad);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(starQuad), this.gl.STATIC_DRAW);
                
                // Dynamic buffers for different star types
                this.buffers.dynamicStarPosition = this.gl.createBuffer();
                this.buffers.dynamicStarSize = this.gl.createBuffer();
                this.buffers.dynamicStarBrightness = this.gl.createBuffer();
            }
            
            generateSphere(latBands, longBands) {
                const vertices = [];
                const indices = [];
                
                for (let lat = 0; lat <= latBands; lat++) {
                    const theta = (lat * Math.PI) / latBands;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    
                    for (let long = 0; long <= longBands; long++) {
                        const phi = (long * 2 * Math.PI) / longBands;
                        const sinPhi = Math.sin(phi);
                        const cosPhi = Math.cos(phi);
                        
                        const x = cosPhi * sinTheta;
                        const y = cosTheta;
                        const z = sinPhi * sinTheta;
                        
                        vertices.push(x, y, z);
                    }
                }
                
                for (let lat = 0; lat < latBands; lat++) {
                    for (let long = 0; long < longBands; long++) {
                        const first = lat * (longBands + 1) + long;
                        const second = first + longBands + 1;
                        
                        indices.push(first, second, first + 1);
                        indices.push(second, second + 1, first + 1);
                    }
                }
                
                return { vertices, indices };
            }
            
            generateCubePositions(size) {
                // Create cube faces only (hollow cube) like the reference image
                const cubeSize = this.isMobile ? 4 : 5; // 5x5 grid on each face
                const positions = [];
                const spacing = 0.5; // Tighter spacing for better cube appearance
                const offset = (cubeSize - 1) * spacing * 0.5;
                
                // Generate cube faces as hollow structure
                for (let x = 0; x < cubeSize; x++) {
                    for (let y = 0; y < cubeSize; y++) {
                        for (let z = 0; z < cubeSize; z++) {
                            // Only place balls on the faces of the cube (hollow cube)
                            const isOnFace = x === 0 || x === cubeSize - 1 || 
                                           y === 0 || y === cubeSize - 1 || 
                                           z === 0 || z === cubeSize - 1;
                            
                            if (isOnFace) {
                                positions.push(
                                    x * spacing - offset,
                                    y * spacing - offset,
                                    z * spacing - offset
                                );
                            }
                        }
                    }
                }
                
                return positions;
            }
            
            setupEventListeners() {
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.canvas.addEventListener('mousemove', (e) => {
                    this.mouseX = (e.clientX / this.canvas.width) * 2 - 1;
                    this.mouseY = (e.clientY / this.canvas.height) * 2 - 1;
                });
                
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                }, { passive: false });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.mouseX = (touch.clientX / this.canvas.width) * 2 - 1;
                    this.mouseY = (touch.clientY / this.canvas.height) * 2 - 1;
                }, { passive: false });
                
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                }, { passive: false });
            }
            
            render() {
                this.time += 0.016;
                
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                
                this.updateStars();
                this.renderStars();
                this.renderSpheres();
                
                requestAnimationFrame(() => this.render());
            }
            
            updateStars() {
                // Update moving stars (bottom-left to top-right)
                this.movingStars.forEach(star => {
                    star.x += star.speed * 0.016;
                    star.y -= star.speed * 0.016 * 0.7;
                    
                    if (star.x > this.canvas.width + 50 || star.y < -50) {
                        star.x = -50;
                        star.y = this.canvas.height + 50;
                    }
                });
                
                // Update exploding stars
                this.explodingStars.forEach(star => {
                    star.nextExplosion -= 0.016;
                    
                    if (star.nextExplosion <= 0 && !star.exploding) {
                        star.exploding = true;
                        star.particles = [];
                        
                        for (let i = 0; i < 12; i++) {
                            const angle = (Math.PI * 2 * i) / 12;
                            star.particles.push({
                                x: star.x,
                                y: star.y,
                                vx: Math.cos(angle) * (Math.random() * 80 + 40),
                                vy: Math.sin(angle) * (Math.random() * 80 + 40),
                                life: 1.0,
                                size: Math.random() * 2 + 1
                            });
                        }
                    }
                    
                    if (star.exploding) {
                        star.particles.forEach(particle => {
                            particle.x += particle.vx * 0.016;
                            particle.y += particle.vy * 0.016;
                            particle.life -= 0.016 * 2;
                        });
                        
                        star.particles = star.particles.filter(p => p.life > 0);
                        
                        if (star.particles.length === 0) {
                            star.exploding = false;
                            star.nextExplosion = Math.random() * 3 + 2;
                            star.x = Math.random() * this.canvas.width;
                            star.y = Math.random() * this.canvas.height;
                        }
                    }
                });
                
                // Update black hole stars (spiral motion)
                const centerX = this.canvas.width * 0.7;
                const centerY = this.canvas.height * 0.3;
                
                this.blackHoleStars.forEach(star => {
                    star.angle += 0.016 * (2 + (200 - star.radius) * 0.01);
                    star.radius *= 0.999;
                    
                    if (star.radius < 10) {
                        star.radius = Math.random() * 150 + 100;
                        star.angle = Math.random() * Math.PI * 2;
                    }
                    
                    star.x = centerX + Math.cos(star.angle) * star.radius;
                    star.y = centerY + Math.sin(star.angle) * star.radius;
                });
            }
            
            renderStars() {
                this.gl.useProgram(this.programs.star);
                
                const projectionMatrix = mat4.create();
                mat4.identity(projectionMatrix);
                
                this.gl.uniformMatrix4fv(
                    this.gl.getUniformLocation(this.programs.star, 'u_projectionMatrix'),
                    false, projectionMatrix
                );
                this.gl.uniform1f(
                    this.gl.getUniformLocation(this.programs.star, 'u_time'),
                    this.time
                );
                this.gl.uniform2f(
                    this.gl.getUniformLocation(this.programs.star, 'u_resolution'),
                    this.canvas.width, this.canvas.height
                );
                
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.starQuad);
                const positionLoc = this.gl.getAttribLocation(this.programs.star, 'a_position');
                this.gl.enableVertexAttribArray(positionLoc);
                this.gl.vertexAttribPointer(positionLoc, 2, this.gl.FLOAT, false, 0, 0);
                
                // Render moving stars
                this.renderStarGroup(this.movingStars);
                
                // Render black hole stars
                this.renderStarGroup(this.blackHoleStars);
                
                // Render exploding star particles
                this.explodingStars.forEach(star => {
                    if (star.exploding) {
                        this.renderStarGroup(star.particles);
                    }
                });
            }
            
            renderStarGroup(stars) {
                if (stars.length === 0) return;
                
                const positions = [];
                const sizes = [];
                const brightness = [];
                
                stars.forEach(star => {
                    positions.push(star.x, star.y);
                    sizes.push(star.size);
                    brightness.push(star.brightness * (star.life || 1));
                });
                
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.dynamicStarPosition);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.DYNAMIC_DRAW);
                const starPosLoc = this.gl.getAttribLocation(this.programs.star, 'a_starPosition');
                this.gl.enableVertexAttribArray(starPosLoc);
                this.gl.vertexAttribPointer(starPosLoc, 2, this.gl.FLOAT, false, 0, 0);
                const ext = this.gl.getExtension('ANGLE_instanced_arrays');
                if (ext && ext.vertexAttribDivisorANGLE) {
                    ext.vertexAttribDivisorANGLE(starPosLoc, 1);
                } else if (this.gl.vertexAttribDivisor) {
                    this.gl.vertexAttribDivisor(starPosLoc, 1);
                }
                
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.dynamicStarSize);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(sizes), this.gl.DYNAMIC_DRAW);
                const starSizeLoc = this.gl.getAttribLocation(this.programs.star, 'a_starSize');
                this.gl.enableVertexAttribArray(starSizeLoc);
                this.gl.vertexAttribPointer(starSizeLoc, 1, this.gl.FLOAT, false, 0, 0);
                if (ext && ext.vertexAttribDivisorANGLE) {
                    ext.vertexAttribDivisorANGLE(starSizeLoc, 1);
                } else if (this.gl.vertexAttribDivisor) {
                    this.gl.vertexAttribDivisor(starSizeLoc, 1);
                }
                
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.dynamicStarBrightness);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(brightness), this.gl.DYNAMIC_DRAW);
                const starBrightnessLoc = this.gl.getAttribLocation(this.programs.star, 'a_starBrightness');
                this.gl.enableVertexAttribArray(starBrightnessLoc);
                this.gl.vertexAttribPointer(starBrightnessLoc, 1, this.gl.FLOAT, false, 0, 0);
                if (ext && ext.vertexAttribDivisorANGLE) {
                    ext.vertexAttribDivisorANGLE(starBrightnessLoc, 1);
                } else if (this.gl.vertexAttribDivisor) {
                    this.gl.vertexAttribDivisor(starBrightnessLoc, 1);
                }
                
                if (ext && ext.drawArraysInstancedANGLE) {
                    ext.drawArraysInstancedANGLE(this.gl.TRIANGLE_FAN, 0, 4, stars.length);
                } else if (this.gl.drawArraysInstanced) {
                    this.gl.drawArraysInstanced(this.gl.TRIANGLE_FAN, 0, 4, stars.length);
                } else {
                    // Fallback: draw each star individually
                    for (let i = 0; i < stars.length; i++) {
                        this.gl.drawArrays(this.gl.TRIANGLE_FAN, 0, 4);
                    }
                }
            }
            
            renderSpheres() {
                this.gl.useProgram(this.programs.sphere);
                
                const projectionMatrix = mat4.create();
                const aspect = this.canvas.width / this.canvas.height;
                mat4.perspective(projectionMatrix, Math.PI / 4, aspect, 0.1, 100.0);
                
                const modelViewMatrix = mat4.create();
                mat4.identity(modelViewMatrix);
                mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -8]);
                
                mat4.rotateX(modelViewMatrix, modelViewMatrix, this.time * 0.5);
                mat4.rotateY(modelViewMatrix, modelViewMatrix, this.time * 0.3);
                mat4.rotateZ(modelViewMatrix, modelViewMatrix, this.time * 0.2);
                
                const mvpMatrix = mat4.create();
                mat4.multiply(mvpMatrix, projectionMatrix, modelViewMatrix);
                
                this.gl.uniformMatrix4fv(
                    this.gl.getUniformLocation(this.programs.sphere, 'u_mvpMatrix'),
                    false, mvpMatrix
                );
                this.gl.uniform1f(
                    this.gl.getUniformLocation(this.programs.sphere, 'u_time'),
                    this.time
                );
                // Dynamic lighting direction
                const lightX = Math.sin(this.time * 0.3) * 0.5 + 0.5;
                const lightY = Math.cos(this.time * 0.2) * 0.3 + 0.7;
                this.gl.uniform3f(
                    this.gl.getUniformLocation(this.programs.sphere, 'u_lightDirection'),
                    lightX, lightY, 1.0
                );
                
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.spherePosition);
                const positionLoc = this.gl.getAttribLocation(this.programs.sphere, 'a_position');
                this.gl.enableVertexAttribArray(positionLoc);
                this.gl.vertexAttribPointer(positionLoc, 3, this.gl.FLOAT, false, 0, 0);
                
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.instancePosition);
                const instancePosLoc = this.gl.getAttribLocation(this.programs.sphere, 'a_instancePosition');
                this.gl.enableVertexAttribArray(instancePosLoc);
                this.gl.vertexAttribPointer(instancePosLoc, 3, this.gl.FLOAT, false, 0, 0);
                
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.instanceScale);
                const instanceScaleLoc = this.gl.getAttribLocation(this.programs.sphere, 'a_instanceScale');
                this.gl.enableVertexAttribArray(instanceScaleLoc);
                this.gl.vertexAttribPointer(instanceScaleLoc, 1, this.gl.FLOAT, false, 0, 0);
                
                const ext = this.gl.getExtension('ANGLE_instanced_arrays');
                if (ext && ext.vertexAttribDivisorANGLE) {
                    ext.vertexAttribDivisorANGLE(instancePosLoc, 1);
                    ext.vertexAttribDivisorANGLE(instanceScaleLoc, 1);
                } else if (this.gl.vertexAttribDivisor) {
                    this.gl.vertexAttribDivisor(instancePosLoc, 1);
                    this.gl.vertexAttribDivisor(instanceScaleLoc, 1);
                }
                
                this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.sphereIndex);
                
                if (ext && ext.drawElementsInstancedANGLE) {
                    ext.drawElementsInstancedANGLE(
                        this.gl.TRIANGLES,
                        this.sphereIndexCount,
                        this.gl.UNSIGNED_SHORT,
                        0,
                        this.instanceCount
                    );
                } else if (this.gl.drawElementsInstanced) {
                    this.gl.drawElementsInstanced(
                        this.gl.TRIANGLES,
                        this.sphereIndexCount,
                        this.gl.UNSIGNED_SHORT,
                        0,
                        this.instanceCount
                    );
                } else {
                    // Fallback: draw each sphere individually
                    for (let i = 0; i < this.instanceCount; i++) {
                        this.gl.drawElements(
                            this.gl.TRIANGLES,
                            this.sphereIndexCount,
                            this.gl.UNSIGNED_SHORT,
                            0
                        );
                    }
                }
            }
        }

        // Start the demo
        window.addEventListener('DOMContentLoaded', () => {
            new BallCubeDemo();
        });
    </script>
</body>
</html>
