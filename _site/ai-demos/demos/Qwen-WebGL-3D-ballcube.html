<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rotating Cube of Balls</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 18px;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
        }
        #title {
            font-size: 24px;
            margin-bottom: 5px;
            color: #4fc3f7;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        #controls label {
            display: block;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="info">
        <div id="title">3D Rotating Cube of Balls</div>
        <div>5x5x5 Grid of Spheres Against a Starry Night Sky</div>
    </div>
    <div id="controls">
        <label><input type="checkbox" id="rotateX" checked> Rotate X</label>
        <label><input type="checkbox" id="rotateY" checked> Rotate Y</label>
        <label><input type="checkbox" id="rotateZ" checked> Rotate Z</label>
        <label>Speed: <input type="range" id="speed" min="0" max="2" step="0.1" value="1"></label>
    </div>
    <canvas id="webgl-canvas"></canvas>

    <script>
        // Minimal mat4 and mat3 functions for matrix operations
        const mat4 = {
            create: function() {
                return new Float32Array(16);
            },
            perspective: function(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[15] = 0;
                if (far != null && far !== Infinity) {
                    const nf = 1 / (near - far);
                    out[10] = (far + near) * nf;
                    out[14] = (2 * far * near) * nf;
                } else {
                    out[10] = -1;
                    out[14] = -2 * near;
                }
                return out;
            },
            lookAt: function(out, eye, center, up) {
                let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
                const eyex = eye[0];
                const eyey = eye[1];
                const eyez = eye[2];
                const upx = up[0];
                const upy = up[1];
                const upz = up[2];
                const centerx = center[0];
                const centery = center[1];
                const centerz = center[2];
                
                z0 = eyex - centerx;
                z1 = eyey - centery;
                z2 = eyez - centerz;
                
                len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                z0 *= len;
                z1 *= len;
                z2 *= len;
                
                x0 = upy * z2 - upz * z1;
                x1 = upz * z0 - upx * z2;
                x2 = upx * z1 - upy * z0;
                len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                if (!len) {
                    x0 = 0;
                    x1 = 0;
                    x2 = 0;
                } else {
                    len = 1 / len;
                    x0 *= len;
                    x1 *= len;
                    x2 *= len;
                }
                
                y0 = z1 * x2 - z2 * x1;
                y1 = z2 * x0 - z0 * x2;
                y2 = z0 * x1 - z1 * x0;
                
                len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
                if (!len) {
                    y0 = 0;
                    y1 = 0;
                    y2 = 0;
                } else {
                    len = 1 / len;
                    y0 *= len;
                    y1 *= len;
                    y2 *= len;
                }
                
                out[0] = x0;
                out[1] = y0;
                out[2] = z0;
                out[3] = 0;
                out[4] = x1;
                out[5] = y1;
                out[6] = z1;
                out[7] = 0;
                out[8] = x2;
                out[9] = y2;
                out[10] = z2;
                out[11] = 0;
                out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
                out[15] = 1;
                
                return out;
            },
            translate: function(out, a, v) {
                const x = v[0], y = v[1], z = v[2];
                let a00, a01, a02, a03;
                let a10, a11, a12, a13;
                let a20, a21, a22, a23;
                
                if (a === out) {
                    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                } else {
                    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
                    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
                    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];
                    
                    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
                    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
                    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;
                    
                    out[12] = a00 * x + a10 * y + a20 * z + a[12];
                    out[13] = a01 * x + a11 * y + a21 * z + a[13];
                    out[14] = a02 * x + a12 * y + a22 * z + a[14];
                    out[15] = a03 * x + a13 * y + a23 * z + a[15];
                }
                
                return out;
            },
            copy: function(out, a) {
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                out[4] = a[4];
                out[5] = a[5];
                out[6] = a[6];
                out[7] = a[7];
                out[8] = a[8];
                out[9] = a[9];
                out[10] = a[10];
                out[11] = a[11];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
                return out;
            }
        };
        
        const mat3 = {
            create: function() {
                return new Float32Array(9);
            },
            normalFromMat4: function(out, a) {
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (!det) {
                    return null;
                }
                det = 1.0 / det;
                
                out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                
                out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                
                out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                
                return out;
            }
        };

        // Main WebGL application
        (function() {
            // Get canvas and WebGL context
            const canvas = document.getElementById('webgl-canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                alert('WebGL not supported by your browser!');
                return;
            }
            
            // Set canvas size
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Vertex shader source
            const vsSource = `
                attribute vec3 aPosition;
                attribute vec3 aNormal;
                
                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;
                uniform mat3 uNormalMatrix;
                
                varying vec3 vNormal;
                varying vec3 vPosition;
                
                void main() {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                    vNormal = uNormalMatrix * aNormal;
                    vPosition = vec3(uModelViewMatrix * vec4(aPosition, 1.0));
                }
            `;
            
            // Fragment shader source
            const fsSource = `
                precision mediump float;
                
                varying vec3 vNormal;
                varying vec3 vPosition;
                
                uniform vec3 uLightPosition;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uDiffuseColor;
                uniform vec3 uSpecularColor;
                uniform float uShininess;
                
                void main() {
                    // Normalize the normal vector
                    vec3 normal = normalize(vNormal);
                    
                    // Direction from fragment to light
                    vec3 lightDir = normalize(uLightPosition - vPosition);
                    
                    // Ambient lighting
                    vec3 ambient = uAmbientColor * uDiffuseColor;
                    
                    // Diffuse lighting
                    float diff = max(dot(normal, lightDir), 0.0);
                    vec3 diffuse = diff * uLightColor * uDiffuseColor;
                    
                    // Specular lighting
                    vec3 viewDir = normalize(-vPosition);
                    vec3 reflectDir = reflect(-lightDir, normal);
                    float spec = pow(max(dot(viewDir, reflectDir), 0.0), uShininess);
                    vec3 specular = spec * uLightColor * uSpecularColor;
                    
                    // Combine lighting
                    vec3 result = ambient + diffuse + specular;
                    gl_FragColor = vec4(result, 1.0);
                }
            `;
            
            // Compile shader
            function compileShader(source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            // Create shader program
            const vertexShader = compileShader(vsSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(fsSource, gl.FRAGMENT_SHADER);
            
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Shader program linking error:', gl.getProgramInfoLog(shaderProgram));
            }
            
            gl.useProgram(shaderProgram);
            
            // Get attribute and uniform locations
            const attribLocations = {
                position: gl.getAttribLocation(shaderProgram, 'aPosition'),
                normal: gl.getAttribLocation(shaderProgram, 'aNormal')
            };
            
            const uniformLocations = {
                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
                lightPosition: gl.getUniformLocation(shaderProgram, 'uLightPosition'),
                lightColor: gl.getUniformLocation(shaderProgram, 'uLightColor'),
                ambientColor: gl.getUniformLocation(shaderProgram, 'uAmbientColor'),
                diffuseColor: gl.getUniformLocation(shaderProgram, 'uDiffuseColor'),
                specularColor: gl.getUniformLocation(shaderProgram, 'uSpecularColor'),
                shininess: gl.getUniformLocation(shaderProgram, 'uShininess')
            };
            
            // Create sphere geometry
            function createSphere(radius, segments) {
                const vertices = [];
                const normals = [];
                const indices = [];
                
                for (let lat = 0; lat <= segments; lat++) {
                    const theta = lat * Math.PI / segments;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    
                    for (let lon = 0; lon <= segments; lon++) {
                        const phi = lon * 2 * Math.PI / segments;
                        const sinPhi = Math.sin(phi);
                        const cosPhi = Math.cos(phi);
                        
                        const x = cosPhi * sinTheta;
                        const y = cosTheta;
                        const z = sinPhi * sinTheta;
                        
                        normals.push(x, y, z);
                        vertices.push(radius * x, radius * y, radius * z);
                    }
                }
                
                for (let lat = 0; lat < segments; lat++) {
                    for (let lon = 0; lon < segments; lon++) {
                        const first = (lat * (segments + 1)) + lon;
                        const second = first + segments + 1;
                        
                        indices.push(first, second, first + 1);
                        indices.push(second, second + 1, first + 1);
                    }
                }
                
                return {
                    vertices: new Float32Array(vertices),
                    normals: new Float32Array(normals),
                    indices: new Uint16Array(indices),
                    indexCount: indices.length
                };
            }
            
            // Create sphere buffers
            const sphere = createSphere(0.15, 16);
            
            const sphereBuffers = {
                position: gl.createBuffer(),
                normal: gl.createBuffer(),
                indices: gl.createBuffer()
            };
            
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereBuffers.position);
            gl.bufferData(gl.ARRAY_BUFFER, sphere.vertices, gl.STATIC_DRAW);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, sphereBuffers.normal);
            gl.bufferData(gl.ARRAY_BUFFER, sphere.normals, gl.STATIC_DRAW);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereBuffers.indices);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphere.indices, gl.STATIC_DRAW);
            
            // Create star background
            function createStars(count) {
                const vertices = [];
                const colors = [];
                
                for (let i = 0; i < count; i++) {
                    // Random position in a sphere around the scene
                    const radius = 20 + Math.random() * 30;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    vertices.push(x, y, z);
                    
                    // Random color (mostly white with some blue/yellow)
                    const r = 0.7 + Math.random() * 0.3;
                    const g = 0.7 + Math.random() * 0.3;
                    const bVal = 0.7 + Math.random() * 0.3;
                    
                    // Make some stars more blue
                    if (Math.random() > 0.8) {
                        // b is already used, so we use bVal
                    }
                    
                    // Make some stars more yellow
                    if (Math.random() > 0.8) {
                        // r and g already adjusted
                    }
                    
                    colors.push(r, g, bVal);
                }
                
                return {
                    vertices: new Float32Array(vertices),
                    colors: new Float32Array(colors),
                    count: count
                };
            }
            
            // Star shader sources
            const starVsSource = `
                attribute vec3 aPosition;
                attribute vec3 aColor;
                
                uniform mat4 uProjectionMatrix;
                uniform mat4 uModelViewMatrix;
                
                varying vec3 vColor;
                
                void main() {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                    gl_PointSize = 2.0;
                    vColor = aColor;
                }
            `;
            
            const starFsSource = `
                precision mediump float;
                
                varying vec3 vColor;
                
                void main() {
                    // Make stars circular
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    if (length(coord) > 0.5) {
                        discard;
                    }
                    
                    // Create a glow effect
                    float distance = length(coord);
                    float alpha = 1.0 - smoothstep(0.0, 0.5, distance);
                    
                    gl_FragColor = vec4(vColor, alpha);
                }
            `;
            
            // Create star shader program
            const starVertexShader = compileShader(starVsSource, gl.VERTEX_SHADER);
            const starFragmentShader = compileShader(starFsSource, gl.FRAGMENT_SHADER);
            
            const starShaderProgram = gl.createProgram();
            gl.attachShader(starShaderProgram, starVertexShader);
            gl.attachShader(starShaderProgram, starFragmentShader);
            gl.linkProgram(starShaderProgram);
            
            // Create star buffers
            const stars = createStars(1000);
            
            const starBuffers = {
                position: gl.createBuffer(),
                color: gl.createBuffer()
            };
            
            gl.bindBuffer(gl.ARRAY_BUFFER, starBuffers.position);
            gl.bufferData(gl.ARRAY_BUFFER, stars.vertices, gl.STATIC_DRAW);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, starBuffers.color);
            gl.bufferData(gl.ARRAY_BUFFER, stars.colors, gl.STATIC_DRAW);
            
            // Set up matrices
            const projectionMatrix = mat4.create();
            const modelViewMatrix = mat4.create();
            const normalMatrix = mat3.create();
            
            // Set up lighting
            const lightPosition = [5.0, 5.0, 5.0];
            const lightColor = [1.0, 0.9, 0.8];
            const ambientColor = [0.1, 0.1, 0.2];
            const diffuseColor = [0.2, 0.4, 0.8];
            const specularColor = [1.0, 1.0, 1.0];
            const shininess = 32.0;
            
            // Set up uniforms for main shader
            gl.uniform3fv(uniformLocations.lightPosition, lightPosition);
            gl.uniform3fv(uniformLocations.lightColor, lightColor);
            gl.uniform3fv(uniformLocations.ambientColor, ambientColor);
            gl.uniform3fv(uniformLocations.diffuseColor, diffuseColor);
            gl.uniform3fv(uniformLocations.specularColor, specularColor);
            gl.uniform1f(uniformLocations.shininess, shininess);
            
            // Rotation control
            let rotation = {
                x: 0,
                y: 0,
                z: 0
            };
            
            // Animation control
            let animationSpeed = 1.0;
            let rotateX = true;
            let rotateY = true;
            let rotateZ = true;
            
            // Set up controls
            document.getElementById('rotateX').addEventListener('change', (e) => {
                rotateX = e.target.checked;
            });
            
            document.getElementById('rotateY').addEventListener('change', (e) => {
                rotateY = e.target.checked;
            });
            
            document.getElementById('rotateZ').addEventListener('change', (e) => {
                rotateZ = e.target.checked;
            });
            
            document.getElementById('speed').addEventListener('input', (e) => {
                animationSpeed = parseFloat(e.target.value);
            });
            
            // Create cube of spheres
            const gridSize = 5;
            const spacing = 0.5;
            const cubePositions = [];
            
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        cubePositions.push([
                            (x - (gridSize - 1) / 2) * spacing,
                            (y - (gridSize - 1) / 2) * spacing,
                            (z - (gridSize - 1) / 2) * spacing
                        ]);
                    }
                }
            }
            
            // Render function
            function render() {
                // Clear the canvas
                gl.clearColor(0.0, 0.0, 0.1, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                
                // Enable depth testing
                gl.enable(gl.DEPTH_TEST);
                
                // Set up projection matrix (perspective)
                mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);
                
                // Set up view matrix (camera)
                const cameraRadius = 8;
                const cameraX = cameraRadius * Math.sin(rotation.y) * Math.cos(rotation.x);
                const cameraY = cameraRadius * Math.sin(rotation.x);
                const cameraZ = cameraRadius * Math.cos(rotation.y) * Math.cos(rotation.x);
                
                const viewMatrix = mat4.create();
                mat4.lookAt(viewMatrix, [cameraX, cameraY, cameraZ], [0, 0, 0], [0, 1, 0]);
                
                // Update rotation
                if (rotateX) rotation.x += 0.005 * animationSpeed;
                if (rotateY) rotation.y += 0.003 * animationSpeed;
                if (rotateZ) rotation.z += 0.002 * animationSpeed;
                
                // Draw stars
                gl.useProgram(starShaderProgram);
                
                const starAttribLocations = {
                    position: gl.getAttribLocation(starShaderProgram, 'aPosition'),
                    color: gl.getAttribLocation(starShaderProgram, 'aColor')
                };
                
                const starUniformLocations = {
                    projectionMatrix: gl.getUniformLocation(starShaderProgram, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(starShaderProgram, 'uModelViewMatrix')
                };
                
                gl.bindBuffer(gl.ARRAY_BUFFER, starBuffers.position);
                gl.enableVertexAttribArray(starAttribLocations.position);
                gl.vertexAttribPointer(starAttribLocations.position, 3, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, starBuffers.color);
                gl.enableVertexAttribArray(starAttribLocations.color);
                gl.vertexAttribPointer(starAttribLocations.color, 3, gl.FLOAT, false, 0, 0);
                
                gl.uniformMatrix4fv(starUniformLocations.projectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(starUniformLocations.modelViewMatrix, false, viewMatrix);
                
                gl.drawArrays(gl.POINTS, 0, stars.count);
                
                // Draw spheres
                gl.useProgram(shaderProgram);
                
                // Set up attribute pointers
                gl.bindBuffer(gl.ARRAY_BUFFER, sphereBuffers.position);
                gl.enableVertexAttribArray(attribLocations.position);
                gl.vertexAttribPointer(attribLocations.position, 3, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, sphereBuffers.normal);
                gl.enableVertexAttribArray(attribLocations.normal);
                gl.vertexAttribPointer(attribLocations.normal, 3, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereBuffers.indices);
                
                // Set projection matrix
                gl.uniformMatrix4fv(uniformLocations.projectionMatrix, false, projectionMatrix);
                
                // Draw each sphere in the cube
                for (let i = 0; i < cubePositions.length; i++) {
                    const pos = cubePositions[i];
                    
                    // Set up model-view matrix
                    mat4.copy(modelViewMatrix, viewMatrix);
                    mat4.translate(modelViewMatrix, modelViewMatrix, pos);
                    
                    // Set up normal matrix
                    mat3.normalFromMat4(normalMatrix, modelViewMatrix);
                    
                    // Set uniforms
                    gl.uniformMatrix4fv(uniformLocations.modelViewMatrix, false, modelViewMatrix);
                    gl.uniformMatrix3fv(uniformLocations.normalMatrix, false, normalMatrix);
                    
                    // Draw the sphere
                    gl.drawElements(gl.TRIANGLES, sphere.indexCount, gl.UNSIGNED_SHORT, 0);
                }
                
                // Request next frame
                requestAnimationFrame(render);
            }
            
            // Start rendering
            render();
        })();
    </script>
</body>
</html>
