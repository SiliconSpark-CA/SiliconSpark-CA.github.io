<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate WebGL Demo: Pulsing Ball Cube in Synced Star Vortex with Audio</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        // Get canvas and WebGL context
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        if (!gl) {
            alert('WebGL 2.0 is not supported by your browser.');
        }

        // Resize function for responsive mobile/desktop
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Setup procedural audio with Web Audio API (subtle pulsing hum synced to rotation)
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        oscillator.type = 'sine';
        oscillator.frequency.value = 110; // Low spacey hum
        const gainNode = audioCtx.createGain();
        gainNode.gain.value = 0.1; // Start quiet
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.start();
        // Resume audio on user interaction (required by browsers)
        document.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }, { once: true });

        // Vertex shader: full-screen quad
        const vsSource = `#version 300 es
            in vec2 aPosition;
            out vec2 vUv;
            void main() {
                vUv = (aPosition + 1.0) * 0.5;
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;

        // Fragment shader: raymarching with all enhancements, restored grid of balls
        const fsSource = `#version 300 es
            precision highp float;

            uniform vec2 uResolution;
            uniform float uTime;

            out vec4 fragColor;

            // Rotation matrices
            mat3 rotateX(float theta) {
                float c = cos(theta), s = sin(theta);
                return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);
            }
            mat3 rotateY(float theta) {
                float c = cos(theta), s = sin(theta);
                return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);
            }
            mat3 rotateZ(float theta) {
                float c = cos(theta), s = sin(theta);
                return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);
            }

            // SDF for sphere
            float sdSphere(vec3 p, float r) {
                return length(p) - r;
            }

            // Scene SDF: spaced grid of balls forming a cube, with pulse
            float sceneSDF(vec3 p) {
                mat3 rot = rotateX(uTime * 0.5) * rotateY(uTime * 0.3) * rotateZ(uTime * 0.2);
                p = rot * p;
                float d = 1e10;
                const float spacing = 0.6;
                float radius = 0.2 + 0.05 * sin(uTime * 2.0 + length(p)); // Pulse effect
                for (float x = -2.0; x <= 2.0; x += 1.0) {
                    for (float y = -2.0; y <= 2.0; y += 1.0) {
                        for (float z = -2.0; z <= 2.0; z += 1.0) {
                            vec3 offset = vec3(x, y, z) * spacing;
                            d = min(d, sdSphere(p - offset, radius));
                        }
                    }
                }
                return d;
            }

            // Raymarching params (optimized steps for perf)
            const int MAX_STEPS = 100;
            const float MIN_DIST = 0.001;
            const float MAX_DIST = 100.0;

            float raymarch(vec3 ro, vec3 rd) {
                float depth = 0.0;
                for (int i = 0; i < MAX_STEPS; i++) {
                    vec3 p = ro + depth * rd;
                    float dist = sceneSDF(p);
                    if (dist < MIN_DIST) return depth;
                    depth += dist * 0.5; // Conservative step for speed
                    if (depth > MAX_DIST) return MAX_DIST;
                }
                return MAX_DIST;
            }

            vec3 calculateNormal(vec3 p) {
                vec2 e = vec2(0.001, 0.0);
                return normalize(vec3(
                    sceneSDF(p + e.xyy) - sceneSDF(p - e.xyy),
                    sceneSDF(p + e.yxy) - sceneSDF(p - e.yxy),
                    sceneSDF(p + e.yyx) - sceneSDF(p - e.yyx)
                ));
            }

            // Compact noise for stars
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0) * 2.0 + 1.0;
                vec4 s1 = floor(b1) * 2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }

            float fbm(vec3 p) {
                float f = 0.0, amp = 0.5;
                for (int i = 0; i < 4; i++) {
                    f += amp * snoise(p);
                    p *= 2.0;
                    amp *= 0.5;
                }
                return f;
            }

            float hash(float n) {
                return fract(sin(n) * 43758.5453);
            }

            // Background: star fields synced to rotation speed
            vec3 background(vec3 rd, float time) {
                vec3 col = vec3(0.0);
                float rotSpeed = 0.5 + 0.3 + 0.2; // Sync to cube rotations

                // Base stars with fbm
                float baseStars = smoothstep(0.9, 1.0, fbm(rd * 10.0 + vec3(time * 0.05 * rotSpeed)));
                col += vec3(baseStars) * 0.5;

                // Diagonal moving stars
                vec3 movingOffset = vec3(time * 0.2 * rotSpeed, time * 0.2 * rotSpeed, 0.0);
                float movingStars = smoothstep(0.95, 1.0, snoise((rd + movingOffset) * 20.0));
                col += vec3(movingStars);

                // Spinning blackhole synced
                vec3 bhDir = normalize(vec3(1.0, 1.0, 1.0));
                float dotBh = dot(rd, bhDir);
                float angleToBh = acos(clamp(dotBh, -1.0, 1.0));
                if (angleToBh < 1.0) {
                    float swirl = time * 2.0 * rotSpeed + 1.0 / (angleToBh + 0.1);
                    vec3 swirledRd = rd + vec3(sin(swirl), cos(swirl), 0.0) * 0.1;
                    float bhStars = smoothstep(0.8, 1.0, fbm(swirledRd * 15.0));
                    col += vec3(bhStars) * vec3(0.8, 0.6, 1.0) * (1.0 - angleToBh);
                }

                // Exploding stars
                for (int i = 0; i < 3; i++) {
                    float seed = float(i) + floor(time / 3.0) * 10.0;
                    vec3 explodeDir = normalize(vec3(hash(seed), hash(seed + 1.0), hash(seed + 2.0)) * 2.0 - 1.0);
                    float phase = fract(time / 3.0);
                    float dotExp = dot(rd, explodeDir);
                    float dist = acos(clamp(dotExp, -1.0, 1.0));
                    float explosion = smoothstep(0.05 + phase * 0.2, 0.0, dist) * (1.0 - phase);
                    col += vec3(explosion) * vec3(1.0, 0.8, 0.5);
                }

                return col * 0.8;
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution) / uResolution.y;

                // Enhanced camera: orbiting, moved further back to fit entire cube even in portrait mode
                float camAngle = uTime * 0.1;
                vec3 ro = vec3(sin(camAngle) * 10.0, 1.0 * sin(uTime * 0.2), cos(camAngle) * 10.0);
                vec3 ta = vec3(0.0, 0.0, 0.0);
                vec3 forward = normalize(ta - ro);
                vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
                vec3 up = cross(forward, right);
                vec3 rd = normalize(forward * 1.5 + right * uv.x + up * uv.y);

                float d = raymarch(ro, rd);

                if (d < MAX_DIST) {
                    vec3 p = ro + d * rd;
                    vec3 n = calculateNormal(p);

                    // Lighting with glow
                    vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
                    float diff = max(dot(n, lightDir), 0.0);
                    vec3 baseColor = vec3(0.0, 0.5, 1.0);
                    vec3 color = baseColor * (0.2 + 0.8 * diff);
                    vec3 viewDir = normalize(ro - p);
                    vec3 halfDir = normalize(lightDir + viewDir);
                    float spec = pow(max(dot(n, halfDir), 0.0), 32.0);
                    color += vec3(1.0) * spec * 0.5;

                    // Add glow based on pulse
                    float glow = 0.5 + 0.5 * sin(uTime * 2.0 + length(p));
                    color += baseColor * glow * 0.3;

                    fragColor = vec4(color, 1.0);
                } else {
                    vec3 bgColor = background(rd, uTime);
                    fragColor = vec4(bgColor, 1.0);
                }
            }
        `;

        // Shader compilation
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(vsSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fsSource, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }
        gl.useProgram(program);

        // Quad setup
        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
        const positionLocation = gl.getAttribLocation(program, 'aPosition');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // Uniforms
        const resolutionLocation = gl.getUniformLocation(program, 'uResolution');
        const timeLocation = gl.getUniformLocation(program, 'uTime');

        // Render loop with audio sync
        let startTime = performance.now();
        function render() {
            const time = (performance.now() - startTime) / 1000.0;
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, time);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // Sync audio pulse to cube rotation/pulse
            const pulse = 0.1 + 0.05 * (0.5 + 0.5 * Math.sin(time * 2.0)); // Match shader pulse
            gainNode.gain.value = pulse;

            requestAnimationFrame(render);
        }
        render();
    </script>
</body>
</html>
